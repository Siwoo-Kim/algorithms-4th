해시테이블 HashTable
    :Hashing 을 이용해 복잡한 데이터 타입을 배열의 인덱스로 바꾸어 배열에 자료를 저장하는 비순차 심볼 테이블.
    해싱을 사용하여 탐색과 삽입 작업을 상수 시간에 완료.

    해싱 Hashing
        : 작은 정수가 아닌 복잡한 데이터 타입을 배열의 인덱스로 변환.

       해시 함수 Hash Function.
            : M개의 키-값 쌍의 배열시 정수 범위 [0, -1] 의 변환 범위에서
            키를 배열에 균일하게 분포시켜주는 함수.

            좋은 해시 함수는 아래를 만족해야 한다.
                1. 일관성 (같은 키라면 항상 같은 해시 값을 가져야 한다)
                2. 효율적인 계산.
                3. 균일한 분포 (해시값은 가능한 키 범위 [0...M-1] 에 균일히 분포되어야 한다.)

            모듈러 해싱 Modular Hashing
                :양의 정수값 k 를 배열 크기 M 을 나누어 나머지를 해시값으로 사용.
                이때 M 을 배열 크기에 가장 가까운 작은 소수로 취한다. (키의 균일성)

                k % M

            문자열에 대한 모듈러 해싱 Modular Hashing
                :적절히 작은 소수 R 과 각 문자 c 에대해 아래 공식을 적용. (자바는 R을 31 로 사용)
                hash = (R * hash + c) % M

            복잡한 키에 대한 모듈러 해싱.
                :문자열에 대한 모듈러 해싱과 같은 방식을 적용.
                hash = 17;
                hash = (R * hash + date);
                hash = (R * hash + month);
                ...

            자바의 해쉬 함수.
                :자바는 모든 객체에 대해 32비트 정수 해시 값을 리턴하는 hashCode 가 정의가 되있다.

            자바의 해쉬 함수 관례
                :해당 데이터 타입에 관해서 hashCode 은 반드시 객체의 동일성과 일관성을 따르도록 한다.

                a.equals(b) 라면 a.hashCode 은 b.hashCode 와 같아야 한다.
                하지만,
                a.hashCode == b.hashCode 라면 반드시 a.equals(b) 가 true 일 필요는 없다.

            자바의 hashCode 값을 배열 인덱스로 변환.
                : hashCode 은 객체의 hash 로 32 비트 정수를 변환하므로
                배열 인덱스로 매핑해야 한다.
                이때 아래 공식을 사용.

                (o.hashCode() & 0x7FFFFFFF) % M; //부호 비트를 제거. M은 적절한 소수를 선택한다.

            소프트웨어 캐싱. (Software Caching)
                : 해시 코드 계산에 시간이 오래 걸린다면 해시 값을 캐싱해둔다.
                이때 객체는 불변이여야 한다.

    충돌 해소 Collision Resolution
        : 다른 키가 같은 배열 인덱스로 매핑되는 충돌 해소.

        개별 체이닝 Separate chaining
            :크기 M인 배열 인덱스의 항목 각각에 연결 리스트 (bucket) 를 두어 해시 값이 같은 복수의 데이터를 저장.
            * M개의 bucket 과 N개의 자료에 대해 bucket 의 평균 길이는 N/M 이다.

            배열 (테이블)의 크기.
                : 배열의 크기 M을 너무 크지도 너무 작지도 않은 적절한 크기 선택이 성능에 있어 중요하다.
                M이 너무 크면 배열에 메모리 낭비가 심하고, M 이 너무 작으면 체인이 길어져 성능이 느려진다.

                아래 공식을 배열의 크기를 동적 변경할 때 사용.
                    * N >= 10*M 이라면 평균 길이가 10 이상.
                    * N <= 2*M 이라면 평균 길이가 2 이하.

            Separate-chaining 의 성능.
                Separate-chaining 해시 테이블에서 M개의 리스트와 N개의 자료가 사용될 때,
                탐색 실패와 삽입 시 소요되는 비교 연산의 횟수는 ~N/M 을 따른다.

        선형-탐지 Linear Probing
            :M > N 인 경우, 해시 값이 충돌 날 때 이미 존재하는 빈 공간에 의존하여 충돌 해소. (open-addressing)

            선형-탐지의 탐색 알고리즘.
                :키를 해싱하고 탐색 키와 매칭되는 키가 그 위치에 있는 검사를 키가 발견되거나
                빈 공간을 찾을 때까지 반복. 이때 배열의 끝에 이르렀다면 앞으로 되돌아간다.

                1. 탐색 키와 현재 키가 동일 - 탐색 성공
                2. 현재 키가 null - 탐색 실패
                3. 탐색 키와 현재 키가 불일치 - 다음 탐색 시도

            삭제
                :삭제된 키 i 에 대해서 오른쪽에 저장된 모든 키를 다시 테이블 삽입해야 한다.
                => 삭제된 키 자리에 null 이 세팅되므로 오른쪽에 저장된 키에 대한 탐색에 대한 원칙이 깨짐.

            Linear-Probing 의 성능
                : 개방형 주소 지정 탐색 (open-addressing search) 의 성능은 a = N/M 비율에 의존.
                이때 a 를 부하 비율 (load factor) 이라 본다.
                a 은 테이블 공간을 키가 차지하고 있는 비율이고 이는 1보다 클 수 없다.
                좋은 성능을 위해 부하비율을 1/8 ~ 1/2 사이에 관리하도록 한다.

                a 의 값이 1/2 근처로 유지한다면 탐지 횟수는 1.5 에서 2.5 사이가 된다.


        개별 체이닝, 선형-탐지의 동적 배열 크기.
            :새로운 HashTable 인스턴스를생성 후 기존 테이블에 저장된 키/값 쌍들을 삽입한다.

            선형-탐지 해쉬 테이블의 크기.
                :Load Factor a 에대해서
                    삽입시 N 이 M/2 보다 크다면 M 을 두배로 늘린다. (a < 1/2)
                    삭제시 N 이 M/8 보다 작다면 M 을 두배로 줄인다. (a > 1/8)

            개별-체이닝 해쉬 테이블의 크기.
                :버킷의 평균 길이를 2에서 8(10) 을 유지.
                    십입시 N >= 8*M 이라면 M 을 두배로 늘인다. (N/M < 8)
                    삭제시 N <= 2*M 이라면 M 을 두배로 줄인다. (N/M > 2)








