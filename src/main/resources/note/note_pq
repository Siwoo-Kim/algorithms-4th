우선순위 큐 (PriorityQueue)
    :최대값의 항목 삭제 그리고 새로운 항목 추가를 지원하는 자료구조.

    우선순위 큐는 모든 항목이 정렬될 필요는 없다.
    항목을 모으며, 그 상황에서 다시 가장 큰 키를 처리하는 점진적인 응용.

    ex)
    작업스케줄링
        :컴퓨터나 스마토폰에서 실행되는 이벤트에 우선순위를 부여하고, 가장 높은 우선 순위의 이벤트에 처리 기회를 먼저 부여.
    정렬 알고리즘
        :모든 항목을 우선순위 큐에 넣은 후 작은 순서대로 꺼내어 정렬 구현.
        입력 스트림의 크기가 너무 커서 제한이 없을때의 정렬시 용이.


    우선순위 큐 API

        void insert(Key k)  // 우선순위 큐에 키 추가
        K max() //가장 큰 키 리턴
        K delMax() //가장 큰 키를 리턴하고 삭제
        boolean isEmpty()   //큐가 비어있는가?
        int size()  //우선순위 큐에 저장된 키의 개수.


    이진 힙 (BinaryHeap)
        :우선순위 큐의 기본 동작을 효율적으로 할 수 있게 해주는 자료구조.

        이진 힙은 최대 항목 삭제에 있어 로그 시간을 보증.
        이진 힙은 완전 이진 트리이다.
            - 따라서 크기가 N 인 이진 힙의 높이는 log N이다.
        이진 힙에서 항목을 배열에 저장할 때 각각의 항목이 특정한 두 위치에 있는 다른 항목보다
        크거나 같다는 조건이 보증한다.

        이진 힙의 불변식 (Binary Heap In-variant)
            힙-정렬
                :각 노드의 두 자식 노드의 키 값이 부모 노드의 키 값보다 작다.
                :힙 정렬된 트리에서 임의의 노드에서 상위 노드로 거슬로 올라가면 오름차순의 시퀀스가 된다.
            * 이진 힙은 항상 힙-정렬 되어있다.
            * 이진 힙의 루트는 모든 노드에서 가장 크다.

        이진 힙의 구현 (Binary Heap Implementation)
            세 개의 링크를 가지는 노드.
                :각 노드는 부모 링크 1개와 자식 링크 2개를 가진다.
            힙-정렬된 완전 이진 트리의 노드들은 그 트리 레벨 순서대로 배열에 나열된다.
            배열의 첫 번째 항목은 사용하지 않는다.
            항상 부모의 위치는 k/2 이다.
            항상 자식의 위치는 2k 와 2k+1.

        힙의 알고리즘 (Heap Algorithms)
            Reheapifying
                :힙 복구 작업이며 힙-정렬의 조건을 만족시키는 알고리즘.
            두 가지 Reheapifying 작업.
                :Swim, Sink

            Swim (상향식 Reheapifying)
                :어떤 노드가 부모 노드보다 커지면서 힙의 순서가 어긋난다면 그 노드를 부모 노드와 교환을 재귀적으로 호출.
                이때 더 큰 노드를 만나거나, 뿌리를 만나면 중단.

            Sink
            (하향식 Reheapifying)
                :어떤 노드가 두 자식 노드들 중 어느 하나보다 작아서 힙의 순서가 어긋나다면 그 노드를 자식 노드들 중에서
                큰 노드와 교환을 재귀적으로 호출.
                이때 노드가 두 자식 노드보다 크거나 같거나 뿌리를 만나면 중단.

        이진힙의 성능
            :N개의 키를 가진 힙에서, 삽입 작업은 1+lgN 이하의 비교 연산을 소요하고,
            최대 항목 삭제 작업은 2 lg N 이하의 비교 연산을 소요.

        다중 힙 (MultiHeap)
            :이진 힙 방식에서 3중 트리 방식으로 수정.

            자식 = 3k-1, 3k, 3k+1
            부모 = (k+1)/3

            다중 힙이 될수록 트리의 높이는 낮아지지만 (log d N), d 개의 자식 중에서 가장 큰 항목을 찾는 비용은 늘어나므로
            이진힙과 트레이드오프 관계가 있다.

        인덱스 방식의 우선순위 큐.
            :많은 응용 환경에서, 클라이언트로 하여금 우선순위 큐에 저장된 항목에
            인덱스로 접근을 허용한다.

            각 항목마다 정수로 된 유일한 식별자로서 인덱스 값을 부여.
                :N개의 항목들을 이진힙을 표현하는 배열에 정하고 별개의 배열에도 저장하여 클라이언트들이
                인덱스를 이용해 항목에 접근을 허용.

            인덱스 방식의 우선순위 큐 API

            void insert(int i, K key)   //인덱스 i에 연결하여 키 삽입.
            void changeKey(int i, K key)    // 인덱스 i에 연결된 키 변경.
            boolean contains(int i)     //인덱스 i에 연결된 키가 존재하는가?
            void delete(int i)      //인덱스 i와 그에 연결된 키를 모두 삭제
            K minKey()      //가장 작은 키를 리턴
            int minIndex()  //가장 작은 인덱스를 리턴
            int delMin()    //가장 작은 키와 인덱스 삭제.
            K keyOf(int i)      //인덱스 i에 연결된 키를 리턴.

        힙 정렬
            :힙 구성(Heap Construction) 과 정렬 취합(Sortdown) 을 이용한 정렬 알고리즘.

            힙 구성은 원본 배열을 힙으로서 재배치하고 정렬 취합은 힙에서 내림차순으로 항목을 꺼내어 정렬된 겨로가를 생성.

        힙 구성
            :오른쪽에서 왼쪽으로 sink 을 하며 순회하며 부분 힙을 생성.
                => 모든 부분이 부분 힙이라면 배열은 하나의 힙으로 구성됨.
                => 이때 순회는 배열의 중간에서 시작 (크기 1짜리인 부분 힙의 순서 복구 작업은 의미가 없으므로)






