이진 탐색 트리 (Binary Search Tree).
    :각 노드가 Comparable 키와 그와 연관된 값을 가지고,
    그 키가 왼쪽 부분 트리의 키보다 크고, 오른쪽 부분 트리의 키보다 작다는 제약을 만족하는 이진 트리.

    연결 리스트가 가진 삽입 작업의 유연성과 정렬된 배열의 효율적 탐색을 결합한 심볼테이블.

    이진 탐색 트리의 특징.
        1. 세 개의 링크 (Link = Directed Edge)
        2. Node (Vertex)
        3. 왼쪽, 오른쪽의 서브 트리. (subtree)

    이진 탐색 트리의 API
        :SymbolTable 의 API

    이진 탐색 트리의 구현 (Binary Search Tree Implementation)
        * 중첩 private Node 클래스를 정의.
        * 노드는 왼쪽, 오른쪽의 링크와 자식 노드의 개수 N을 가진다.
            :N는 size(node) = size(node.left) + size(node.right) + 1

        이진 탐색 트리의 불변식 (Binary Tree In-variant)
            1. 모든 노드는 단 하나의 들어오는 링크만을 가진다.
            2. 모든 노드는 단 하나의 부모만을 가진다. (1과 같은 규칙)
            3. 모든 왼쪽 서브트리는 루트보다 작다.
            4. 모든 오른쪽 서브트리는 루트보다 크다.

        이진 탐색 트리의 탐색 알고리즘 (Binary Tree's Search Algorithms)
            1. 노드가 null 이면 탐색 실패.
            2. 노드의 키가 탐색 키와 같으면 탐색 성공.
            3. 노드의 키가 탐색 키보다 크다면 왼쪽 서브 트리를 재귀적 탐색.
            4. 노드의 키가 탐색 키보다 작다면 오른쪽 서브 트리를 재귀적 탐색.

        이진 탐색 트리의 삽입 알고리즘 (Binary Tree's Insertion Algorithms)
            1. 노드가 null 이면 새로운 키/쌍의 노드를 생성하여 리턴.
            2. 노드의 키가 탐색 키와 같다면 값을 변경.
            3. 노드의 키가 탐색 키보다 크다면 왼쪽 서브 트리의 결과를 새로운 왼쪽 링크로 연결.
            4. 노드의 키가 탐색 키보다 작다면 오른쪽 서브 트리의 결과를 새로운 오른쪽 링크로 연결.

        이진 탐색의 분석.
            :이진 탐색 트리 알고리즘의 실행 시간은 트리 모양에 종속적이다.
            최적 조건은 Complete Binary Tree 이며, N 개의 노드가 있을 때 뿌리와 null 링크 사이엔 log N개의 노드가 존재한다.
            최악 조건은 탐색 경로에서 N개의 노드 모두를 거쳐야 하는 상황이며 이는 연결 리스트의 성능 분석과 같다.

        최소, 최대.
            1. 뿌리 노드의 왼쪽 링크가 null 이라면 뿌리가 가장 작은 노드이다.
            2. 왼쪽 링크가 null 이 아니라면 왼쪽 링크로 하는 서브 트리에서 최소 키가 전체 트리의 최소 키이다.
            최대 노드 도 최소 노드 구하는 알고리즘을 활용.

        floor, ceiling
            1. 주어진 키가 루트의 키보다 작다면 탐색 키의 floor 은 반드시 왼쪽 부분 트리에 존재.
            2. 주어진 키가 루트의 키보다 크다면
                1-1) 그 키보다 작거나 같은 트리가 오른쪽 부분 트리에 존재한다면
                탐색 키의 floor 은 반드시 오른쪽 부분 트리에 존재.
                1-2) 아니라면 오른쪽으로 분기된 루트의 키가 floor 의 키이다.
                증명: floor 의 키는 항상 탐색 키보다 작거나 같아야 하므로, 오른쪽 서브 트리에 존재 하지 않다면
                해당 루트의 키가 같진 않지만 트리에서 현존하는 가장 작은 키이다.

            ceiling 도 floor 와 같은 알고리즘을 활용.

        rankOf
            탐색 순위 순위 k 에 대해서.
                왼쪽 부분 트리의 갯수 = t.
            1. t 가 k 보다 크다면 순위 k 인 키는 왼쪽 서브 트리에 존재.
            2. t 가 k 와 같다면 해당 노드를 리턴.
            3. t 가 k 보다 작다면 k - t - 1 의 순위를 오른쪽 서브 트리에서 탐색.

        rank
            왼쪽 부분 트리의 갯수를 t라고 했을 때.
            1. 주어진 키가 노드의 키와 같다면 t 를 리턴.
            2. 주어진 키가 노드의 키보다 작다면 왼쪽 서버 트리의 rank(t) 리턴.
            3. 주어진 키가 노드의 키보다 크다면 t + 1 (현재 뿌리) + rank(t) 리턴.

        removeMin, removeMax
            가장 작은 노드를 찾아 대체 노드로 오른쪽 링크 선택.
            이때 가장 작은 노드는 참조가 없어지기에 가비지 컬력센의 대상이 된다.

        remove
            자식 노드가 하나 혹은 없을때 removeMin 과 같은 방식.
            만약 어떤 노드 x에 대해 x의 자식 노드가 둘이라면, 그 근후행(successor) 노드에게 자리를 물려준다.
                *Successor 근후행
                    :순위상 뒤에 있는 노드들 중에서 가장 가까운 노드
                    만약 오른쪽 부분 트리를 근후행의 소스라 본다면 오른쪽 부분 트리에서 가장 작은 키가 Successor.
                    반대로 왼쪽 부분 트리를 근후행의 소스라 본다면 왼쪽 부분 트리에서 가장 큰 키가 Successor.

            삭제할 노드 x에 대해
            1. 삭제할 노드를 t 에 백업한다.
            2. x 에 Successor 을 대입한다.
                :x 의 successor = min(x.right)
            3. x 의 right 링크를 deleteMin(t) 에 연결한다.
                이때 근후행에 대한 삭제를 실행한 서브 트리가 리턴된다.
                이때 근후행은 x.right 의 최소 노드였으므로 x.key 보다 큰 모든 키를 가진 BST 을 가리킨다.
            4. x 의 left 링크를 t의 left 로 연결한다.
                이때 t.left 은 삭제된 키와 근후행 키 두 키보다 작은 키를 모둔 가진 bst 임이
                BST 의 불변식으로 증명된다.






