정렬
    :객체들이 나열된 순서를 어떤 논리적 순서에 맞도록 바꾸는 작업.

    정렬 학습 이유
        * 다른 정렬 알고리즘 간의 비교 방법을 배울 수 있다.
        * 정렬 알고리즘에 쓰이는 테크닉은 다른 문제에도 활용 가능.
        * 알고리즘 구현을 위해 정렬부터 시작하는 경우가 많다.

    정렬 알고리즘 고려 사항.
        * 실행 시간
            :알고리즘의 기본 작업을 몇 번이나 수행해야 알고리즘 간 성능 차이를 비교할 수 있다.
        * 추가 메모리
            :주어진 배열의 메모리에 직접 작업 혹은 배열을 복제하여 정렬 결과를 저장하는 방식.
        * 데이터 타입
            :정렬할 배열의 항목은 Comparable 을 구현해야 한다.

            Comparable 인터페이스
                :같은 데이터 타입간의 논리적 순서를 규정.

                Comparable 의 convention
                    반사율: 모든 v에 대해 v = v
                    대칭률: 모든 v, w에 대해 v < w 이면 w > v 이고 v = w 이면 w = v 이다.
                    추이율: 모든 v, w, x에 대해 v <= w 이면서 w <= x 이면 v <= x 이다.

    선택 정렬 (Selection Sort)
        :배열 안에서 가장 작은 항목을 찾아, 배열의 i(0~N-1)와 자리 바꿈을 반복.
        선택 정렬은 길이 N의 배열에 대해 N^/2 번의 비교와 N번의 교환 수행.

        선택 정렬의 특성.
            * 실행 시간이 입력에 민감하다
                :각 순회시 가장 작은 항목을 찾는 절차는 그 다음번의 순회에 추가적인 정보를 주지 않는다.
                다른 알고리즘은 초기 입력이 이미 어느 정도 정렬된 상태면 더 나은 성능을 낸다.
            * 데이터의 이동을 최소화
                :교환 횟수는 배열의 크기에 선형이 비례.

    삽입 정렬 (Insertion Sort)
        :항목 i 에 대해서 이미 살펴본 항목 사이에서 적합한 위치로 옮김을 반복.
        삽입 정렬은 최악 조건에서 N^2 번의 비교와 N^2/2 번의 교환을 수행하고
        최적 조건에서는 N-1 번의 비교와 0번의 교환을 수행.
        삽입 정렬의 실행 시간은 선택 정렬과 달리 초기 입력 배열의 정렬된 상태에 의존적.

    쉘 정렬 (Shell Sort)
        :삽입 정렬이 게반을 둔 알고리즘.
        서로 멀리 떨어진 i+h 간에 교환으로 사전 작업하고 이후에 삽입 정렬을 빠르게 처리.

        매 h번째 항목들 간에 순서를 따질 때 정렬된 상태가 되도록 배열을 정리.
        이렇게 부분적으로 정렬된 배열을 "h-정렬" 되었다라고 한다.
        위를 h가 1이 될때까지 반복하면 결국 배열 전체가 정렬.

        이때 h은 아무 숫자가 될 수 있지만 해당 앱에서는 1/2(3^k-1) 의 순열을 사용.
        1..4..13..40

            쉘 "h" 구하기
                while (h < N / 3)
                    h = h * 3 + 1;

        쉘의 성능.
            For 10000 random Doubles
             Insertion is 1.0 times faster than Selection
            For 10000 random Doubles
             Shell is 30.6 times faster than Selection

    병합 정렬 (Merge Sort)
        :배열을 반으로 나누어 각각의 절반에 대해 재귀적으로 정렬을 수행 후
        다시 재귀적으로 정렬 결과를 병합.

        크기 N인 배열을 정렬하는 시간은 N log N

        병합 정렬의 알고리즘 (Merge) In-variant
            :두 부분 배열, a[low..mid] 와 a[mid+1..high] 을 병합.

            * 왼쪽 배열이 소진.
            * 오른쪽 배열이 소진.
            * 현재 키의 오른쪽이 왼쪽보다 작다.
            * 현재 키의 오른쪽이 왼쪽보다 크거나 같다.

        분할 정복 알고리즘 패러다임과 "병합 정렬"
            :병합 정렬은 매우 작은 부분 배열들의 대한 정렬로 문제를 쪼갠 후 병합하여 배열을 정렬.

            분할 정복 알고리즘 패러다임
                : 문제를 잘게 쪼개서 각각의 부분 문제들을 해결한 후,
                그 결과를 이용해 다시 전체 문제를 푸는 접근 방법.

    퀵 정렬 (Quick Sort)
        :분할 정복 방식의 정렬 방식으로, 배열을 부분 배열로 분할 (partitioning)
        한 다음 각각의 부분 독립적으로 정렬.

        퀵-정렬은 배열 a[low..high] 을 부분 배열로 나누고 각각의 부분 배열에 대해 재귀적으로 정렬을 호출.
        부분 배열은 partition 메서드를 통해 a[j] 기준으로 나누어진다.
        partition 메서드는 전체 재귀 호출이 끝나면 배열이 정렬된 상태가 되도록 pivot(=j) 를 선택한다.

        퀵-정렬 invariant (Quick Sort Invariant)
            * a[j] 의 pivot 은 부분 배열에서 최종적으로 정렬된 정렬 위치.
            * a[lo..j-1] 이르는 항목은 a[j] 보다 작다.
            * a[j+1..hi] 이르는 항목은 a[j] 보다 크다.
            * 배열의 모든 부분이 pivot 이 된다면 배열은 전체 정렬.

        퀵-정렬의 partition 알고리즘.
            1. 임의의 항목 a[lo] 를 "분할 기준 항목"으로 선정.
            2-1 배열의 왼쪽 끝부터 "분할 기준 항목" 보다 크거나 같은 항목을 만날때가지 스캔.
            2-2 배열의 오른쪽 끝부터 "분할 기준 항목" 보다 작거나 같은 항목을 만날때가지 스캔.
            3. 두 항목을 찾았다면 두 큰 항목을 교환.












